import '../models/message_model.dart';

class MessageExportService {
  /// Export message as plain text
  static String exportAsText(MessageModel message) {
    return '''Message for ${message.recipientType}
Tone: ${message.tone}
Date: ${message.createdAt.toString().split('.')[0]}

${message.generatedText}

---
Generated by AI Mood
''';
  }

  /// Export message as markdown
  static String exportAsMarkdown(MessageModel message) {
    return '''# Message for ${_capitalizeFirst(message.recipientType)}

**Tone:** ${_capitalizeFirst(message.tone)}  
**Created:** ${message.createdAt.toString().split('.')[0]}

> ${message.generatedText}

---
*Generated by AI Mood*
''';
  }

  /// Export multiple messages as CSV
  static String exportAsCSV(List<MessageModel> messages) {
    StringBuffer csv = StringBuffer();
    csv.writeln('ID,Recipient,Tone,Content,Created,Saved');

    for (var msg in messages) {
      csv.writeln(
        '"${msg.id}","${msg.recipientType}","${msg.tone}","${msg.generatedText.replaceAll('"', '""')}","${msg.createdAt}","${msg.isSaved}"',
      );
    }

    return csv.toString();
  }

  /// Export message for email
  static String exportForEmail(MessageModel message) {
    return '''<html>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
  <h2 style="color: #6366F1;">Message for ${_capitalizeFirst(message.recipientType)}</h2>
  
  <div style="background-color: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
    <p>${message.generatedText.replaceAll('\n', '<br>')}</p>
  </div>
  
  <div style="font-size: 12px; color: #999; margin-top: 20px;">
    <p><strong>Tone:</strong> ${_capitalizeFirst(message.tone)}</p>
    <p><strong>Created:</strong> ${message.createdAt.toString().split('.')[0]}</p>
  </div>
  
  <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
  <p style="font-size: 11px; color: #999;">Generated by AI Mood - Your personal message generator</p>
</body>
</html>
''';
  }

  static String _capitalizeFirst(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }
}

class MessageSharingService {
  /// Share message via native share dialog
  static Future<void> shareMessage(MessageModel message) async {
    // TODO: Implement using share_plus package or native sharing
    // For now, just return
    return;
  }

  /// Share to WhatsApp
  static Future<void> shareToWhatsApp(MessageModel message) async {
    // TODO: Implement WhatsApp sharing
    // final text = Uri.encodeComponent('''${message.content}
    //
    // ---
    // Generated with AI Mood''');
    // This would typically open WhatsApp if installed
    // For now, fallback to standard share
    await shareMessage(message);
  }

  /// Share to Twitter
  static Future<void> shareToTwitter(MessageModel message) async {
    // TODO: Implement Twitter sharing
    // final text = Uri.encodeComponent(
    //   '${message.content}\n\nGenerated with #AIMood',
    // );
    // This would typically open Twitter if installed
    // For now, fallback to standard share
    await shareMessage(message);
  }

  /// Copy to clipboard
  static Future<void> copyToClipboard(String text) async {
    // This would typically use flutter/services.dart Clipboard
    // Placeholder for now - depends on flutter package
  }
}

class MessageAnalyticsService {
  /// Calculate average message length
  static double calculateAverageLength(List<MessageModel> messages) {
    if (messages.isEmpty) return 0.0;
    final total = messages.fold<int>(
      0,
      (sum, msg) => sum + msg.generatedText.length,
    );
    return total / messages.length;
  }

  /// Count messages by recipient
  static Map<String, int> countByRecipient(List<MessageModel> messages) {
    final counts = <String, int>{};
    for (var msg in messages) {
      counts[msg.recipientType] = (counts[msg.recipientType] ?? 0) + 1;
    }
    return counts;
  }

  /// Count messages by tone
  static Map<String, int> countByTone(List<MessageModel> messages) {
    final counts = <String, int>{};
    for (var msg in messages) {
      counts[msg.tone] = (counts[msg.tone] ?? 0) + 1;
    }
    return counts;
  }

  /// Calculate total words generated
  static int calculateTotalWords(List<MessageModel> messages) {
    return messages.fold(
      0,
      (sum, msg) => sum + msg.generatedText.split(' ').length,
    );
  }

  /// Get longest messages
  static List<MessageModel> getLongestMessages(
    List<MessageModel> messages, {
    int limit = 5,
  }) {
    final sorted = List<MessageModel>.from(messages);
    sorted.sort(
      (a, b) => b.generatedText.length.compareTo(a.generatedText.length),
    );
    return sorted.take(limit).toList();
  }

  /// Get recently created messages
  static List<MessageModel> getRecentMessages(
    List<MessageModel> messages, {
    int days = 7,
  }) {
    final cutoffDate = DateTime.now().subtract(Duration(days: days));
    return messages.where((msg) => msg.createdAt.isAfter(cutoffDate)).toList();
  }

  /// Calculate generation frequency
  static Map<String, dynamic> getGenerationStats(List<MessageModel> messages) {
    return {
      'totalMessages': messages.length,
      'totalWords': calculateTotalWords(messages),
      'averageLength': calculateAverageLength(messages),
      'byRecipient': countByRecipient(messages),
      'byTone': countByTone(messages),
      'savedCount': messages.where((m) => m.isSaved).length,
    };
  }
}
